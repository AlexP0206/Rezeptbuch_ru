<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rezeptbuch</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: none; /* мы сами управляем жестами в области книги */
    }

    /* Контейнер книги на весь экран с safe-area */
    #app {
      width: 100vw;
      height: 100vh;   /* fallback */
      height: 100dvh;  /* iOS 16+ */
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Область просмотра */
    #viewer {
      width: 100%;
      height: 100%;
      display: grid;
      gap: 0;
      background: #000;
    }

    /* 1 страница по умолчанию; для iPad landscape мы переключим на 2 колонки через JS */
    #viewer.one  { grid-template-columns: 1fr; }
    #viewer.two  { grid-template-columns: 1fr 1fr; }

    .pane {
      position: relative;
      overflow: hidden;         /* чтобы зум не выходил за рамки панели */
      background: #000;
      touch-action: none;       /* важное для pinch */
    }

    .pane img {
      width: 100%;
      height: 100%;
      object-fit: contain;      /* целиком без обрезки */
      transform-origin: center center;
      will-change: transform;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;     /* чтобы жесты ловила панель */
    }

    /* Небольшой индикатор страницы */
    #hud {
      position: fixed;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 14px;
      padding: 6px 10px;
      border-radius: 999px;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="app">
  <div id="viewer" class="one">
    <div class="pane" id="paneL"><img id="imgL" alt=""></div>
    <div class="pane" id="paneR" style="display:none;"><img id="imgR" alt=""></div>
  </div>
</div>

<div id="hud"></div>

<script>
  // ---- Настрой: список страниц
  const pages = [
    "pages/page_1.jpg",
    "pages/page_2.jpg",
    "pages/page_3.jpg",
    "pages/page_4.jpg",
    "pages/page_5.jpg"
  ];

  const viewer = document.getElementById("viewer");
  const paneL = document.getElementById("paneL");
  const paneR = document.getElementById("paneR");
  const imgL  = document.getElementById("imgL");
  const imgR  = document.getElementById("imgR");
  const hud   = document.getElementById("hud");

  // ---- Определяем режим отображения
  function isIPad() {
    // iPadOS может маскироваться под Mac, поэтому проверяем touch + ширину
    return navigator.maxTouchPoints > 1 && Math.max(screen.width, screen.height) >= 1024;
  }

  function isPortrait() {
    return window.matchMedia("(orientation: portrait)").matches;
  }

  function shouldShowTwoPages() {
    // iPad landscape -> 2 страницы, iPad portrait -> 1 страница
    // iPhone всегда 1 страница
    return isIPad() && !isPortrait();
  }

  // ---- Состояние книги
  let index = 0; // индекс левой страницы (в one-page режиме это просто текущая)
  const zoomState = {
    L: { scale: 1, x: 0, y: 0 },
    R: { scale: 1, x: 0, y: 0 }
  };

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  function applyTransform(which) {
    const st = zoomState[which];
    const img = which === "L" ? imgL : imgR;
    img.style.transform = `translate(${st.x}px, ${st.y}px) scale(${st.scale})`;
  }

  function resetZoom(which) {
    zoomState[which] = { scale: 1, x: 0, y: 0 };
    applyTransform(which);
  }

  function setMode() {
    const two = shouldShowTwoPages();

    if (two) {
      viewer.classList.remove("one");
      viewer.classList.add("two");
      paneR.style.display = "block";
    } else {
      viewer.classList.remove("two");
      viewer.classList.add("one");
      paneR.style.display = "none";
    }
    render();
  }

  function render() {
    const two = shouldShowTwoPages();

    if (two) {
      // Следим, чтобы index был четным (чтобы развороты шли парами)
      if (index % 2 !== 0) index -= 1;
      index = clamp(index, 0, pages.length - 1);

      imgL.src = pages[index] ?? "";
      imgR.src = pages[index + 1] ?? "";
      hud.textContent = `${index + 1}–${Math.min(index + 2, pages.length)} / ${pages.length}`;
    } else {
      index = clamp(index, 0, pages.length - 1);
      imgL.src = pages[index] ?? "";
      hud.textContent = `${index + 1} / ${pages.length}`;
    }

    // при смене страниц сбрасываем зум (чтобы не “таскать” старый масштаб)
    resetZoom("L");
    resetZoom("R");
  }

  // ---- Листание свайпом (работает, когда не зумим)
  let swipeStartX = 0;
  let swipeStartY = 0;

  function isZoomed() {
    return zoomState.L.scale > 1.01 || zoomState.R.scale > 1.01;
  }

  document.getElementById("app").addEventListener("touchstart", (e) => {
    if (e.touches.length !== 1) return;
    swipeStartX = e.touches[0].clientX;
    swipeStartY = e.touches[0].clientY;
  }, { passive: true });

  document.getElementById("app").addEventListener("touchend", (e) => {
    if (isZoomed()) return; // когда зум активен — не листаем
    const dx = e.changedTouches[0].clientX - swipeStartX;
    const dy = e.changedTouches[0].clientY - swipeStartY;

    if (Math.abs(dx) < 50 || Math.abs(dx) < Math.abs(dy)) return;

    const two = shouldShowTwoPages();
    if (dx < 0) {
      // next
      index += two ? 2 : 1;
    } else {
      // prev
      index -= two ? 2 : 1;
    }
    render();
  }, { passive: true });

  // ---- Pinch-zoom + pan (на каждой панели отдельно)
  function attachPinchPan(pane, which) {
    let startDist = 0;
    let startScale = 1;
    let lastX = 0, lastY = 0;
    let startX = 0, startY = 0;
    let isPanning = false;

    function dist(t1, t2) {
      const dx = t2.clientX - t1.clientX;
      const dy = t2.clientY - t1.clientY;
      return Math.hypot(dx, dy);
    }

    pane.addEventListener("touchstart", (e) => {
      if (which === "R" && paneR.style.display === "none") return;

      if (e.touches.length === 2) {
        e.preventDefault();
        startDist = dist(e.touches[0], e.touches[1]);
        startScale = zoomState[which].scale;
        isPanning = false;
      } else if (e.touches.length === 1 && zoomState[which].scale > 1.01) {
        e.preventDefault();
        isPanning = true;
        startX = e.touches[0].clientX - zoomState[which].x;
        startY = e.touches[0].clientY - zoomState[which].y;
      }
    }, { passive: false });

    pane.addEventListener("touchmove", (e) => {
      if (which === "R" && paneR.style.display === "none") return;

      if (e.touches.length === 2) {
        e.preventDefault();
        const d = dist(e.touches[0], e.touches[1]);
        const factor = d / startDist;
        const nextScale = clamp(startScale * factor, 1, 4);
        zoomState[which].scale = nextScale;
        applyTransform(which);
      } else if (e.touches.length === 1 && isPanning) {
        e.preventDefault();
        zoomState[which].x = e.touches[0].clientX - startX;
        zoomState[which].y = e.touches[0].clientY - startY;
        applyTransform(which);
      }
    }, { passive: false });

    pane.addEventListener("touchend", () => {
      // если вернулись к масштабу 1 — сбрасываем сдвиги
      if (zoomState[which].scale <= 1.01) {
        resetZoom(which);
      }
      isPanning = false;
    }, { passive: true });

    // двойной тап: быстрый зум 1 <-> 2
    let lastTap = 0;
    pane.addEventListener("touchend", (e) => {
      if (e.changedTouches.length !== 1) return;
      const now = Date.now();
      if (now - lastTap < 280) {
        // toggle
        if (zoomState[which].scale > 1.01) resetZoom(which);
        else {
          zoomState[which].scale = 2;
          zoomState[which].x = 0;
          zoomState[which].y = 0;
          applyTransform(which);
        }
        lastTap = 0;
      } else {
        lastTap = now;
      }
    }, { passive: true });
  }

  attachPinchPan(paneL, "L");
  attachPinchPan(paneR, "R");

  // ---- Реакция на поворот экрана / resize
  window.addEventListener("orientationchange", () => setTimeout(setMode, 150));
  window.addEventListener("resize", () => setTimeout(setMode, 150));

  // старт
  setMode();
</script>

</body>
</html>
